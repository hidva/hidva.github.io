---
title: "认清性能问题"
tags: [读后感]
---

# 基本概念

任务, 响应时间, 吞吐量, 参见原文了解这些概念的定义. 这里吞吐量与响应时间看似是倒数关系, 但实际上并没有这么简单, 要想知道这两个指标, 就必须一起测量它们. 另外关于响应时间的描述, 一般采用百分位的形式, 常见的描述有: 50%, 90%, 99%, 99.9%, 再加一个平均响应时间.

负载; 负载是并发任务执行时引发的资源竞争. 负载的一个测量指标是使用率. 资源使用率反应了资源按时间分片的使用情况. 一个直观的感受是当负载上升时, 那么请求该资源服务的用户就不得不经历更长的响应时间. 注意这里负载是指特定单个资源的负载. 在现实生活中, 任务的执行往往会涉及到多种资源.

队列延迟现象; 这里先基于 M/M/m 理论从理论上分析队列延迟, 然后再将理论分析结果应用到现实. M/M/m 系统模型: 系统中有 m 个服务通道数. 这里服务通道是一种资源, 若任务分配到不同的服务通道, 则相互之间不会互相影响. 分配到相同服务通道的任务由于共享同一个队列会引发相应的竞争. 比如 linux 内核系统中, 一个 CPU 核就是一个服务通道, 不同核上的任务(进程)互不影响(忽略访存内存带来的竞争等), 同一核上则会排队执行. M/M/m 理论假设系统拥有理论上的完美扩展性; 按我理解这里完美扩展性是指系统内的服务通道数可以任意无限增加; 现实生活中该假设往往不能成立, 比如在计算机系统中, 由于内存, 总线这些共享资源的存在导致不能无限增加 cpu 核数, 所以才会引入 NUMA 这些玩意. M/M/m 理论中, 任务响应时间 R 等于任务排队时间 Q 与任务执行时间 S 之和; 其中任务执行时间 S 是指去除排队之后, 纯粹的执行时间, 按我理解应该是个常量; Q 是指任务在队列中等待机会所花费的时间, 与资源利用率 p 成某种函数关系. 所以 R 与资源利用率 p 成某种函数关系, 参见原文 R-p 函数关系图. 按我理解这里 p 应该是指单个服务通道的利用率, 或者说是整个系统中所有服务通道的平均资源利用率.

M/M/m 理论中的拐点; 拐点就是响应时间 R 除以资源利用率 p 所得结果最小的值. 拐点有个很好的属性, 就是位于从原点画一条直线正好与响应时间曲线相切的位置, 参见原文图示. 拐点另一个很好的属性是你只需要知道系统服务通道数 m 的取值就可以计算出它, 参见原文图表了解不同服务通道数时拐点的取值.

M/M/m 理论与拐点的现实意义. 现实系统中往往会有多类资源; 其中每一项资源都有一个拐点; 而且由于现实系统并不具有完美的可扩展性, 所以实际拐点取值会小于理论拐点. 拐点又称最优负载平衡点, 因为在这点吞吐量被最大化了而且对响应时间只有很小的负面影响, 此时的吞吐量又可称为是系统的容量. 根据原文 R-p 曲线可以看到如果资源负载持续超过拐点, 那么响应时间和吞吐会因为负载的轻微变化而严重波动, 因此保持负载低于拐点是至关重要的.

随机到达, 随机到达的请求往往会聚集导致资源使用脉冲式上升从而会由于队列延迟导致某些请求响应时间剧烈波动. 此时需要用足够的容量来消化这些脉冲式上涨的资源需求, 确保资源利用率不会超过拐点, 或者不会长时间(大于8秒, 引自互联网 8 秒原则)地超出拐点. 在请求到达系统的时间完全是确定的情况下, 此时请求不会聚集, 即不会有队列延迟或者队列延迟可控, 所以此时的目标是让资源利用率达到 100%.

相关性延迟现象; 执行任务时花在对共享资源访问的协商和通信的时间就是相关性延迟. 相关性延迟依赖除资源利用率之外的随机性因素, 参见原文的举例. 在引入相关性延迟之后, 任务可能会永久阻塞而无法完成. 这里以一个现实例子来展示相关性延迟以及队列延迟, 一个基于 `std::list<Task> q` 实现的多生产者单消费者; 在生产者往 `q` 中提交任务时, 由于 `q` 可能存在并行读写, 所以会先获取锁, 然后往 `q` 追加任务, 然后释放锁; 消费者会从 `q` 中取出任务并执行. 这里生产者在提交任务时的加锁释放锁操作所花费的时间就是相关性延迟; 在生产者提交任务到 `q` 之后到任务被从 `q` 中取出执行这段时间就是队列延迟.


# 最佳实践

性能优化一般姿势; 首先利用工具确定程序的热点位置, 这里的工具就像原文用的 UML, 性能剖析, 或者更为常用的 gpref 等. 然后结合阿姆达尔定律, 实施成本等各个方面来确定最终如何实施优化.

性能测试一般姿势; 首先为所有你可以预见的生产问题去建立模型和测试是极其困难的. 因此在完全不测试和完整的生产环境模拟测试之间, 存在一个适度测试量的平衡点.

性能数据采集; 在系统中引入性能数据采集模块肯定会对系统表现带来损耗, 但经验表明在利用好采集模块采集数据之后, 采集模块带来的收益远大于其引入的性能损失, 所以这也是为啥 linux kernel, mysql 等系统都引入详细性能数据采集模块的原因吧. 另外不要做过早的优化对于采集模块同样有效, 即先确认采集模块采集的数据足够有效果之后再优化采集模块. 关于具体采集指标的选择, 警惕哪些替代指标, 参见原文了解替代指标的概念. 我到觉得既然替代指标的采集很方便, 那么多一个总比少一个好.



# 参考

-   [认清性能问题][20180920221141]

[20180920221141]: <https://mp.weixin.qq.com/s/5vtvmoLKvz-x-Pi3-kIdwA> "最后修订: 2018-04-23"
