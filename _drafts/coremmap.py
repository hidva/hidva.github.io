# -*- coding: UTF-8 -*-

# 根据 corefile 中信息生成若干 mmap 语句,
# 之后可以创建一个进程, 执行这些 mmap 语句, 这样我们就能得到一个与 corefile 一样内存环境的 live process
# 再之后我们可以基于这个 live process 做一些事情.
# 使用姿势:
#  coremmap.py $corepath > mmap.c
# Use python2.7/python3
import sys, bisect
import subprocess
import logging
import re


logging.basicConfig(
    format="%(asctime)s|%(process)d|%(thread)d|%(name)s|%(levelname)s|%(message)s", level=logging.INFO)


CORE_NT_FILE_HEADER = re.compile(r'^CORE\s*0x[a-f0-9]+\s*NT_FILE\s*\(mapped files\)\s*$')
NT_FILE_END = re.compile(r'^(CORE|LINUX)\s*0x[a-f0-9]+\s*NT_.*$')
PAGE_SIZE_LINE = re.compile(r'^Page size: ([0-9]+)\s*$')
START_END_PAGEOFF_HEADER = re.compile(r'^Start\s*End\s*Page Offset\s*$')
UNKNOWN_PAGE_SIZE = -1

# COPY: jegdb.py
# 输入: maintenance info sections
# 输出: 若干互不相交的地址区间
class Merger(object):
  def __init__(self):
    # self.data [(left, right)], 每一个元素表明 [left, right) 区间, 元素之间不相交, 并且按照 left 从小到大排序.
    self.data_l = []
    self.data_r = []

  # 若 [left, right) 表明的区间与 self.data 某一区间相交, 则合入该区间. 否则新插入到 self.data 中.
  def insert(self, left, right):
    idx = bisect.bisect_left(self.data_l, left)
    merge_l = idx > 0 and left <= self.data_r[idx - 1]
    merge_r = idx < len(self.data_l) and right >= self.data_l[idx]
    if not merge_l and not merge_r:
      self.data_l.insert(idx, left)
      self.data_r.insert(idx, right)
      return
    if merge_l and not merge_r:
      self.data_r[idx - 1] = max(right, self.data_r[idx - 1])
      return
    if not merge_l and merge_r:
      self.data_l[idx] = left
      self.data_r[idx] = max(right, self.data_r[idx])
      return
    # merge_l and merge_r
    self.data_r[idx - 1] = max(right, self.data_r[idx])
    self.data_l.pop(idx)
    self.data_r.pop(idx)
    return


# input: readelf -n 的输出结果
# return: [(start, end, fileoff, file)]
def parse_readelf_n(input):
  page_size = UNKNOWN_PAGE_SIZE
  mappings = []
  had_core_nt_file_header = False
  for line in input.splitlines():
    line = line.strip()
    if not line:
      continue
    if not had_core_nt_file_header:
      if CORE_NT_FILE_HEADER.match(line):
        had_core_nt_file_header = True
      continue
    if page_size == UNKNOWN_PAGE_SIZE:
      res = PAGE_SIZE_LINE.match(line)
      if res:
        page_size = int(res.group(1))
      continue
    if START_END_PAGEOFF_HEADER.match(line):
      continue
    if NT_FILE_END.match(line):
      break
    mappings.append(line)
  assert page_size != UNKNOWN_PAGE_SIZE
  assert len(mappings) % 2 == 0
  ret = []
  for idx in xrange(0, len(mappings), 2):
    vals = mappings[idx].split()
    assert len(vals) == 3
    start = int(vals[0], 0)
    end = int(vals[1], 0)
    pageoff = int(vals[2], 0) * page_size
    filepath = mappings[idx + 1]
    ret.append((start, end, pageoff, filepath))
  return ret


# readelf -l /home/t4/corefile/core-holo-worker-25-1670252063-bd033022018130.ea119 | grep -F 'LOAD' -A 1 | less
# return: [(start, end, fileoff)]
def parse_readelf_l(input):
  input = [i.strip() for i in input.splitlines()]
  assert len(input) % 2 == 0
  ret = []
  for idx in xrange(0, len(input), 2):
    second_parts = input[idx + 1].split()
    filesize = int(second_parts[0], 0)
    if filesize <= 0:
      continue
    first_parts = input[idx].split()
    assert first_parts[0] == 'LOAD'
    fileoff = int(first_parts[1], 0)
    virtaddr = int(first_parts[2], 0)
    ret.append((virtaddr, virtaddr + filesize, fileoff))
  return ret


# 文件路径与其对应 fd 变量的映射
g_filepath_var = {}
def get_filepath_fd(codes, filepath):
  fdvar = g_filepath_var.get(filepath)
  if fdvar:
    return fdvar
  fdvar = 'hidva_fd_%s' % len(g_filepath_var)
  codes.append('  int %s = open("%s", O_RDONLY);' % (fdvar, filepath))
  codes.append('  if (%s < 0) { fprintf(stderr, "ERROR: open failed. path=%s err=%%m\\n"); }' % (fdvar, filepath))
  codes.append('  else { fprintf(stderr, "INFO: open success. path=%s\\n"); }' % (filepath))
  codes.append('')
  g_filepath_var[filepath] = fdvar
  return fdvar


def main():
  corepath = sys.argv[1]
  note_mappings = parse_readelf_n(subprocess.check_output(["readelf", "-n", corepath]))
  ph_mappings = parse_readelf_l(subprocess.check_output("readelf -l %s | grep -F 'LOAD' -A 1" % (corepath), shell=True))
  for m in ph_mappings:
    note_mappings.append((m[0], m[1], m[2], corepath))
  # 针对对同一 virtaddr 的映射, ph_mappings 优先级高于 note_mappings.
  # 所以先执行 note_mappings 再执行 ph_mappings,
  # Linux kernel: If the memory region specified by addr and length overlaps pages of any existind mapping(s),
  # then the overlapped part of the existind mapping(s) will be discarded.

  codes = []
  codes.append('/* Generated by hidva.com/coremmap, 大吉大利 */')
  # 需要手动指定当前 binary section addr, 避免与 corefile 冲突.
  codes.append('/* gcc -Wl,-Tbss=0x0000800000000000 -Wl,-Tdata=0x0000900000000000 -Wl,-Ttext=0x0000a00000000000 */')
  codes.append('')
  codes.append('#include <fcntl.h>')
  codes.append('#include <stdio.h>')
  codes.append('#include <unistd.h>')
  codes.append('#include <sys/mman.h>')

  merger = Merger()
  codes.append('int main(int argc, char**argv) {')
  for nm in note_mappings:
    vmstart, vmend, fileoff, filepath = nm
    merger.insert(vmstart, vmend)
    nm = (hex(vmstart), hex(vmend), fileoff, filepath)
    nm = 'vmstart=%s vmend=%s fileoff=%s filepath=%s' % nm
    if vmend <= vmstart:
      logging.info("ignore vm=%s", nm)
      continue
    fdvar = get_filepath_fd(codes, filepath)
    codes.append('  if (%s < 0) { fprintf(stderr, "ERROR: open failed, can not mmap. vm=%s\\n"); }' % (fdvar, nm))
    codes.append('  else { ')
    codes.append('    void* ret = mmap((void*)%sUL, %s, PROT_READ, MAP_PRIVATE|MAP_FIXED, %s, %s);' % (vmstart, vmend - vmstart, fdvar, fileoff))
    codes.append('    if (ret == MAP_FAILED) { fprintf(stderr, "ERROR: mmap failed. vm=%s\\n"); }' % (nm,))
    codes.append('    else { fprintf(stderr, "INFO: mmap. vm=%s\\n"); }' % (nm,))
    codes.append('  } ')
    codes.append(' ')
  # logging.info("merger: %s", [(merger.data_l[i], merger.data_r[i]) for i in xrange(0, len(merger.data_l))])

  codes.append('  /* ADD YOUR LOGIC HERE */')
  codes.append('  pause(); ')
  codes.append('  return 0;')
  codes.append('}')
  print('\n'.join(codes))
  return


if __name__ == '__main__':
  main()
