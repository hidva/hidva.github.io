---
title: 编译器设计读书笔记
tags: [读后感]
---



# 第 1 章,  编译概观

这里讲述的东西大部分已经熟知, 所以这里只介绍一些概念相关的知识点.

语法; 程序语言语法通过某种规则的有限集定义了源语言集合; 这里语法规则是有限的, 而源语言集合是无限的. 词类, syntactic category, 又叫语法范畴, 语法规则中使用词类来引用单词, 这里词类是一堆具有公共特征的单词的总称, 比如 "标识符" 词类是所有可以作为标识符的单词的总称.词素, lexeme; 可以看为是词类的一个具体实例. 词类与语法单元, 按我理解在程序设计语言语法描述中, 词类是最小的, 不可再划分的粒度; 而语法单元则可以根据语法规则进一步划分, 直至划分为词类. 词法分析器扫描输入, 生成 '(单词所属词类, 单词具体值)' 流. 语法分析器扫描该流, 再根据语法来验证该流是否属于语法定义的源语言集合. microsyntax, 程序设计语言中用来描述词法结构的规则, microsyntax 定义了词类以及词类中单词的字符组合形式. 所以就能看出来了词法分析器根据 microsyntax 将字符流转换为单词流, 语法分析器根据语法验证单词流是否合法.

ILOC, intermediate language for an optimizing compiler, 可以看作某种简单的 RISC 机器的汇编语言. 参见原文了解 ILOC 语言的一些细节. 

编译期指令调度, 运行时指令调度; 很显然编译期指令调度由编译器完成, 运行时指令调度由 CPU 完成. 一直以来只是知道指令调度的存在, 但却不是很清楚指令调度的具体效果; 原来举了个例子展示了通过指令调度将性能提升一倍的案例, 可以了解一下.

# 第 2 章, 词法分析器

## 2.2 识别单词

还是先了解一些概念.

状态转移图, 起始状态, 接受状态. 再来看一些状态转移图的某些约定: 接受状态以双层圆圈绘制. 通常会省去目标为错误状态的转移, 因此识别器在遇到输入字符无法匹配到状态的某个转移时, 就转移到错误状态. 状态转移图中可以存在环, 来表明到自身的转移.

FA, 有限自动机, 其定义参考原文. 转移图是 FA 的形式化表示, FA 与转移图一一对应. 另外这里可能还有一个 "接受" 的概念, FA 接受字符串 x 的充分必要条件可以参考原文了解一下.

## 2.3 正则表达式

还是先介绍一些概念。这里的概念最好要摸清楚, 不然后面会很迷糊吃力.

语言，单词的集合. ~~这里单词可以认为是词素, 语言这个概念名感觉有点违和~~。FA 定义的语言记为 L(F)，即 FA 接受的字符串集合。

连接, 闭包, 选择; 定义于集合之上的操作, 或者说运算符, 注意这里操作数是集合, 数学中的那个集合. 运算符具体定义参考原文了解. 

正则表达式，正则表达式是一种符号表示法，描述了某个字母表 $$\sum$$ 上的字符串集合，即正则表达式也定义了一个语言, 记为 L(RE), 又称为正则语言。字母表 $$\sum$$ 上正则表达式集合的构造参见原文, 这里的构造方式定义了什么是正则表达式, 以及该正则表达式定义的语言(即字符串集合)是什么. 注意这里所使用的 '选择', '闭包', '连接' 是定义在正则表达式之上的运算符, 与上面定义在集合之上的同名运算符是两回事, 虽然两者很类似. 科学论证表明，FA 与正则表达式一一对应。

正则表达式运算符; 除了上述介绍的三种基本运算符之外, 正则表达式还支持其他运算符. 正闭包, 定义见原文. 有限闭包, 定义在原文. 求补^, 这个运算符原文没有精确地介绍, 按我理解, 对于 ^R 而言, 这里要求 $$L(R)$$ 的元素必须是字母表 $$\sum$$ 上的字母, 即 $$L(R)$$ 是 $$\sum$$ 的子集, L(^R) 等于字母表 $$\sum - L(R)$$.  求补~, ~~这个运算符原文并没有介绍就直接用了, 让我一度很困惑~~. 参考 wiki 百科定义, $$\sim R$$ 等于 $${\sum} ^ * - L(R)$$, 这里 $${\sum} ^ * $$ 表示 
$$
(a_1 | a_2 | ... | a_n) ^ *
$$, 其中$$\left \{ a_1, a_2,...,a_n  \right \} == \sum$$.  这里除了三种基本运算符之外的所有运算符都可以用三种基本运算符重写, 有限闭包, 正闭包这些显而易见, 对于求补~运算符, 按照 wiki 百科的说法也是可以重写的, 只是过程复杂了一些, ~~反正我是没有脑补出如何重写~~. 另外这里也可以看出正则表达式在三种基本运算符下是封闭的, 即将运算符应用到一个或一组正则表达式之上, 结果仍然是一个正则表达式.

正则表达式的运算符优先级; 首先 '()' 仍然具有最大的优先级, 其余依次是: '求补^', '闭包*', '连接', '选择'. 是的原文并没给出所有运算符的优先级, 我也没有办法.

字符范围表示, 定义参见原文, ~~这里为啥不用通用的 '[a-z]', 而是 '[a...z]' 呢?! 另外这里字符范围表示应该不能看作定义在正则表达式之上的运算符~~.

正则表达式 R 的补集 $$~R$$  对应的 FA; 这里记 R 对应的 FA 为 $$\left \{ S, \sum, \delta, s_0,S_A  \right \}$$; 则 $$~A$$ 对应的 FA 为 $$\left \{ S, \sum, \delta, s_0, S-S_A  \right \}$$, 即交换了原来 FA 的接受状态与非接受状态.

  
## 2.4 从正则表达式到词法分析器

构造法的循环，参见原文这张图，有点意思。

### 2.4.1 非确定性有限自动机

老规矩, 先看一下基本概念.

NFA, 非确定性有限自动机, DFA, 确定性有限自动机; 定义参见原文. NFA 对应的状态转移图通过引入$$\epsilon$$转移来表示这种不确定性, 以原文图那个用来识别 mn 的状态转移图举例, 当处在$$s_0$$状态, 遇到 m 时, 其可以转移到$$s_1$$, 也可以转移到$$s_2$$. 原文也提到了两个模型, 用来描述 NFA 的行为, 以期来让 NFA 的行为更具有确定性, ~~这里的模型2感觉就像多重宇宙理论中所说的当遇到不确定性事, 就派生出一个新的宇宙~~. 根据下文可知, 原文更倾向于使用模型 2 来描述 NFA 的行为.

NFA 的配置, 就是 NFA 状态的集合; 所以具有 n 个状态的 NFA 配置最多为 $$2^n$$, 即长度为 n 的集合的子集个数. 原文存在一个错误, 其认为配置总数是$$
{\left | \sum  \right |} ^ n
$$, [这里](https://cs.stackexchange.com/questions/80388/the-upper-bound-on-a-nondeterministic-finite-automatas-configurations-number)也有位仁兄看出来了. NFA 验证一个字符串是否被接受的过程也就是 NFA 从一个配置跳到另一个配置的过程, 还是以原文那个用来识别 mn 的状态转移图举例, 当其用来验证输入串 "mn" 时, 其会首先从配置$$\left \{ s_0 \right \}$$跳到$$\left \{ s_1, s_2 \right \}$$最后到$$\left \{ s_3 \right \}$$. 所以 NFA 接受一个字符串的充分必要条件是配置跳转路径中最后一个配置中存在至少一个终结状态. 

### 2.4.2 从正则表达式到 NFA: Thompson 构造法

Thompson 构造法大致流程: 首先为输入 RE 中每个字符构造简单的 NFA, 构造姿势参考原文; 然后按照正则表达式运算符的优先级, 将操作数对应的 NFA 按照运算符的语义转换为一个 NFA, 相当于将正则表达式运算符应用在一个或一组 NFA 上得到一个结果 NFA. 在此过程中, 始终遵循如下性质:

1.  每个构造出来的 NFA 都仅有一个起始状态, 都仅有一个接受状态; 不存在到起始状态的转移; 不存在从接受状态出发的转移.
2.  each state has at most two entering and two exiting $\epsilon$$moves, and at most one entering and one exiting move on a symbol in the alphabet. ~~原文对这句的翻译感觉怪怪的~~.
3.  在连接 NFA 时, 总是使用$$\epsilon$$转移将左操作数 NFA 的接受状态与右操作数 NFA 的起始状态连接在一起.

NFA 运算, 这里介绍一下如何将一个或一组 NFA 按照正则表达式运算符的语义转换为一个结果 NFA, 由上可知, 任何正则表达式运算符都可重写为三种基本运算符: 闭包, 连接, 选择, 所以这里只会介绍这三种 NFA 运算, 如下图所示:

![nfa op]({{site.url}}/assets/nfa.png)

# 参考

编译器设计, 第2版.

